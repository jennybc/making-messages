{
  "articles": [
    {
      "path": "01-intro.html",
      "title": "Typical message making tasks and challenges",
      "author": [],
      "contents": "\nWe need to emit:\nInformational messages\nError messages\n\nI’m ignoring warnings, because I use them so seldom, but a full treatment should cover them. Our lifecycle policies, in particular, lean heavily on warnings.\nWhat do these messages tend to look like, in the wild, using base tools?\nbase::message() and base::stop()\nFirst, let’s review the signatures of message() and stop().\n\n\nmessage(..., domain = NULL, appendLF = TRUE)\nstop(..., call. = TRUE, domain = NULL)\n\n\n\nBoth make make a message from the loose parts that come via ..., which is documented as:\n\nzero or more objects which can be coerced to character (and which are pasted together with no separator)\n\nHere’s a tour of message() calls sprinkled around tidyverse / r-lib, with me pointing out small, recurring challenges. I’ll often have to make some fake objects, so we can actually run the code.\nThis is about characterizing the problem space as we find it and foreshadowing some existing solutions we already use and some improvement proposals I want to make.\nSyntactical noise and readability\nThe alternation between literal strings and strings stored as character objects causes a lot syntactical noise. This is why many of us embrace the interpolation offered by the glue package, which I’ll use as a running comparator.\n\n\nlibrary(glue)\n\npath <- \"path/to/a/thing\"\nmessage(\"Caching nycflights db at \", path)\n\n\n#> Caching nycflights db at path/to/a/thing\n\n\n# glue-ified\nmessage(glue(\"Caching nycflights db at {path}\"))\n\n\n#> Caching nycflights db at path/to/a/thing\n\n\ndim_f <- c(4, 7)\nunits <- \"inch\"\nmessage(\"Saving \", dim_f[1], \" x \", dim_f[2], \" \", units, \" image\")\n\n\n#> Saving 4 x 7 inch image\n\n\n# glue-ified\nmessage(glue(\"Saving {dim_f[1]} x {dim_f[2]} {units} image\"))\n\n\n#> Saving 4 x 7 inch image\n\nsprintf() offers some hope of relief, because at least the single format string eliminates lots of quotes.\n\n\nname <- \"thing\"\nreplacement <- \" by doohickey\"\nversion <- \"1.0.0\"\nmessage(sprintf(\"%s is deprecated%s. Deprecated in version '%s'.\",\n                name, replacement, version))\n\n\n#> thing is deprecated by doohickey. Deprecated in version '1.0.0'.\n\n\n# glue-ified\nmessage(glue(\n  \"{name} is deprecated{replacement}. Deprecated in version '{version}'.\"\n))\n\n\n#> thing is deprecated by doohickey. Deprecated in version '1.0.0'.\n\nI’d still rather write, read, and maintain the glue version. You don’t have to bounce between the format string and the arguments supplying values, doing tedious counting or substitution in your head.\nConclusion: string interpolation is critical for any function that makes messages.\nLiteral quotes (or other inline style)\nOften you want to surround an interpolated stored string with an actual quoting symbol, so it’s clearly distinguished as, e.g., a variable or package name or a field. This invites a very specific set of mistakes: not enough backslashes, backslashes in the wrong place, and unbalanced quotes.\n\nIf available, you might use color and/or other styling (e.g., bold, underline) for this purpose.\n\n\nFMT <- \"FORMAT\"\nmessage(\"Using: \\\"\", FMT, \"\\\"\")\n\n\n#> Using: \"FORMAT\"\n\n\nelement <- \"ggplot2.thingy\"\nmessage(\"Theme element `\", element, \"` missing\")\n\n\n#> Theme element `ggplot2.thingy` missing\n\n\n# glue-ified\nmessage(glue(\"Using: \\\"{FMT}\\\"\"))\n\n\n#> Using: \"FORMAT\"\n\nmessage(glue('Using: \"{FMT}\"'))   # some single / double quote games\n\n\n#> Using: \"FORMAT\"\n\nmessage(glue(\"Theme element `{element}` missing\"))\n\n\n#> Theme element `ggplot2.thingy` missing\n\n\nYes, you can play some single vs. double quote games, but it only gets you so far.\nConclusion: Messages are not just “flat” strings. You really need inline styles to convey all the necessary information.\nSpoiler: this is the motivation for the cli package’s semantic CLI functionality, which has roots in the ui_*() functions in usethis.\nCollapsing lists of things\nIt’s pretty common that your message incorporates a collection of items Here you see a lot of paste() and friends, used with the collapse argument.\n\n\nx <- structure(1, class = c(\"alfa\", \"bravo\", \"charlie\"))\nmessage(\"Don't know how to automatically pick scale for object of type \",\n        paste(class(x), collapse = \"/\"), \". Defaulting to continuous.\")\n\n\n#> Don't know how to automatically pick scale for object of type alfa/bravo/charlie. Defaulting to continuous.\n\n\n# glue-ified\nmessage(glue(\"\n Don't know how to automatically pick scale for object of type \\\\\n {glue_collapse(class(x), sep = '/')}. Defaulting to continuous.\"            \n))\n\n\n#> Don't know how to automatically pick scale for object of type alfa/bravo/charlie. Defaulting to continuous.\n\n\nmsg <- c(\"'this'\", \"'that'\")\nmessage(\"`geom_smooth()` using \", paste0(msg, collapse = \" and \"))\n\n\n#> `geom_smooth()` using 'this' and 'that'\n\n\n# glue-ified\nmessage(glue(\"`geom_smooth()` using {glue_collapse(msg, sep = ' and ')}\"))\n\n\n#> `geom_smooth()` using 'this' and 'that'\n\nConclusion: Often we want to inject an array of strings and collapse it with some attention to aesthetics, conventions, and grammar.\n\nThe need to collapse lists often co-occurs with the need for inline style. A closely related problem is allocating message parts (e.g. list items) to different lines, e.g. making bullet lists.\nThe next example really starts to show multiple ergonomic problems interacting with each other, i.e. working over a list of interpolated strings and dealing with line breaks.\n\n\norig_name <- c(a = \"o1\", b = \"o2\")\nname <- c(a = \"n1\", b = \"n2\")\nnew_names <- c(\"b\", \"a\")\n\nmessage(\n  \"New names:\\n\",\n  paste0(orig_name[new_names], \" -> \", name[new_names], collapse = \"\\n\")\n)\n\n\n#> New names:\n#> o2 -> n2\n#> o1 -> n1\n\n\n# glue-ified\nnms <- glue(\"{orig_name[new_names]} -> {name[new_names]}\\n\")\nnms <- glue_collapse(nms, sep = \"\\n\")\nmessage(glue(\"New names:\\n{nms}\"))\n\n\n#> New names:\n#> o2 -> n2\n#> o1 -> n1\n\nWe’re also starting to see some challenges with glue, where you need to make several calls in sequence, to build up the message. I’ve decided the explicit management of newlines (\\n) is a strong indicator that there’s some missing bit of tooling.\nLet’s go out with an extravaganza of interpolation, inline styling and collapsing!\n\n\ntrained <- c(alfa = \"apple\", bravo = \"banana\")\nmessage(\"Multiple formats matched: \",\n        paste(\"\\\"\", names(trained), \"\\\"(\", trained, \")\", sep = \"\",\n              collapse = \", \"))\n\n\n#> Multiple formats matched: \"alfa\"(apple), \"bravo\"(banana)\n\n\n# glue-ified\nx <- glue('\"{names(trained)}\"({trained})')\ny <- glue_collapse(x, sep = \", \")\nmessage(glue(\"Multiple formats matched: {y}\"))\n\n\n#> Multiple formats matched: \"alfa\"(apple), \"bravo\"(banana)\n\n\n\n\n",
      "last_modified": "2021-03-12T18:51:11+00:00"
    },
    {
      "path": "about.html",
      "title": "About this site",
      "author": [],
      "contents": "\nSource repo: https://github.com/jennybc/making-messages\nMade with distill: “documentation” site | “reference” site (pkgdown)\n\n\n\n",
      "last_modified": "2021-03-12T18:51:12+00:00"
    },
    {
      "path": "index.html",
      "title": "Making messages",
      "description": "Welcome to the website. I hope you enjoy it!\n",
      "author": [],
      "contents": "\nIntro\n\n\n\n",
      "last_modified": "2021-03-12T18:51:12+00:00"
    }
  ],
  "collections": []
}
